\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{indentfirst}


\begin{document}

\section*{Лабораторная работа №\,9 по курсу дискрeтного анализа: Алгоритмы для работы с графами}

Выполнил студент группы М8О-207Б МАИ \textit{Цапков Александр}.

\subsection*{Условие}

\begin{enumerate}
\item Разработать программу на языке C или C++, реализующую указанный алгоритм согласно заданию:

Задан взвешенный ориентированный граф, состоящий из n вершин и m ребер. Вершины пронумерованы целыми числами от 1 до n. Необходимо найти величину максимального потока в графе при помощи алгоритма Форда-Фалкерсона. Для достижения приемлемой производительности в алгоритме рекомендуется использовать поиск в ширину, а не в глубину. Истоком является вершина с номером 1, стоком – вершина с номером n. Вес ребра равен его пропускной способности. Граф не содержит петель и кратных ребер.

\item Вариант: 7

\end{enumerate}

\subsection*{Метод решения}
Как и написано в варианте, задачу нужно решать при помощи алгоритма Форда-Фалкерсона. Этот алгоритм достаточно прост. Мы просто ищем любой путь из истока в сток и пускаем там максимум сколько можем пустить (минимальное значений пропускной способности из всех задествованных ребер). При этом мы модифищируем граф и если мы пустили из $V_1$ в $V_2$ n и уменьшили пропускную способность $V_1$ $V_2$, то мы увеличиваем пропускную способность $V_2$ $V_1$ на это же самое значение n. Это можно понять так-- если мы пустили что-то в одном направлении, то в седующий раз мы можем это же количество или меньшее не пускать, что приведет к переизбытку в истоке ребра на какое-то значение и к недостатку в его стоке на такое же значение, что по сути эквивалентно запуску потока в обротном направлении.


\subsection*{Описание программы}

Моя программа состоит из 2-х файлов: Graph.hpp с реализацией класса для работы с графами и файла main.cpp с реализацией самого алгоритма. Для решения задачи мы просто ищем путь из истока в сток, уменьшеем пропускную способность в положиельном направлении маршрута и увеличиваем в обратном, перестраивая граф. Как только мы не можем найти новый путь, мы построили максимальный поток, и, сложив все те значения потоков на каждой из итераций мы получаем искомое значение максимального потока.

\subsection*{Дневник отладки}

1-е 2 посылки: ошибка компиляции. Чекер не знает что такое INT\_MAX, заменил на \_\_INT\_MAX\_\_.

3-я посылка: ошибка компиляции. Чекеру не понравился мой порядок классов.

4-я посылка: неправильный ответ, максимальный поток может быть больше инта.

5-я посылка: ожидает подтверждения.
\subsection*{Тест производительности}

Я производил как такогого теста производительности, но ее можно определить по алгоритму. Мы прводим несколько итераций, в каждой из которых мы производим поиск в ширину(за линию) и перестраиваем граф, за линию от маршрута. Таких итераций мы выполняем в худшем случае M раз, где M-- это велечина максимального потока. Получаем сложность O(MN). 

\subsection*{Выводы}

В этой лабараторной работе я реализовал алгоритм которому меня научили еще на 1-м курсе на Дискретной математике, когда мы проходили теорию графов. Я не получил с этой лр много новых знаний, зато заметил какой путь я прошел за год, и насолько легче теперь выполнять работу по написанию таких програм сейчас, нежели год назад.

\end{document}

